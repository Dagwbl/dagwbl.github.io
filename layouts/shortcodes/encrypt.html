{{ $hint := .Get "hint" | default "è¯·è¾“å…¥å¯†ç " }}
<div class="encrypted-content" data-cipher="{{ .Inner | base64Encode | replaceRE "(.{5})(.{3})(.{4})(.+)" "$2$4$1$3" }}" data-hint="{{ $hint }}">
    <div class="locked-state">
        <p>ğŸ”’ æ­¤å¤„å†…å®¹å·²åŠ å¯†</p>
        <div class="password-prompt">
            <input type="password" class="password-input"
                   placeholder="{{ $hint }}" 
                   id="pwd-input-{{ .Ordinal }}"
                   aria-label="åŠ å¯†å†…å®¹å¯†ç ">
            <button class="decrypt-btn" onclick="decryptContent(event, 'pwd-input-{{ .Ordinal }}')">è§£é”</button>
        </div>
        <div class="status-message"></div>
    </div>
    <div class="decrypted-content markdown-body" hidden></div>
</div>

<style>
.encrypted-content {
  border: 1px solid #878787;
  border-radius: 0.5rem;
  padding: 1.5rem;
  margin: 1.5rem 0;
  background-color: #fff;
  transition: all 0.3s ease;
}

.encrypted-content.unlocked {
  border: none;
  padding: 0;
  margin: 0;
  background: transparent;
}

.password-prompt {
  display: flex;
  gap: 0.75rem;
  margin: 1rem 0;
}

.password-input {
  flex: 3;
  min-width: 200px;
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 0.25rem;
}

.password-input.error {
  border-color: #dc3545;
}

.decrypt-btn {
  padding: 0.75rem 1.25rem;
  background-color: var(--primary, #1e90ff);
  color: var(--theme);
  border: none;
  border-radius: 0.25rem;
  cursor: pointer;
  transition: opacity 0.3s;
  font-weight: 500;
  flex: 1;
}

.decrypt-btn:hover {
  opacity: 0.9;
}

.decrypted-content {
  margin-top: 1rem;
  color: #333;
}

.status-message {
  color: #6c757d;
  font-size: 0.9em;
  min-height: 1.2em;
}

.status-message.error {
  color: #dc3545;
}
</style>

<script>
function decryptContent(event, inputId) {
  event.preventDefault();
  const input = document.getElementById(inputId);
  if (!input) return;

  const container = input.closest('.encrypted-content');
  const statusEl = container.querySelector('.status-message');
  const decryptedContent = container.querySelector('.decrypted-content');
  
  statusEl.textContent = '';
  input.classList.remove('error');

  // è®¡ç®—åŸºäºæ—¥æœŸçš„å¯†ç 
  const today = new Date();
  const mmdd = String(today.getUTCMonth() + 1).padStart(2, '0') + String(today.getUTCDate()).padStart(2, '0');
  const validCode = String(1005 - parseInt(mmdd)).padStart(4, '0');

  if (input.value !== validCode) {
    input.classList.add('error');
    statusEl.textContent = `å¯†ç é”™è¯¯ï¼`;
    statusEl.classList.add('error');
    input.focus();
    return;
  }

  try {
    // ä»æ··æ·†çš„Base64æ¢å¤åŸå§‹å­—ç¬¦ä¸²å¹¶è§£ç 
    let cipherText = container.dataset.cipher
      .replace(/\s+/g, '')
      .replace(/-/g, '+')
      .replace(/_/g, '/');

    // åæ··æ·†å¤„ç† - è¿˜åŸå­—ç¬¦å—
    const len = cipherText.length;
    if (len > 12) {
      const part1 = cipherText.substring(0, 3);
      const part2 = cipherText.substring(3, len - 9);
      const part3 = cipherText.substring(len - 9, len - 4);
      const part4 = cipherText.substring(len - 4);
      cipherText = part3 + part1 + part4 + part2;
    }

    // Base64è§£ç æˆå­—èŠ‚æ•°ç»„
    const binaryStr = atob(cipherText);
    const byteArray = new Uint8Array(binaryStr.length);
    for (let i = 0; i < binaryStr.length; i++) {
        byteArray[i] = binaryStr.charCodeAt(i);
    }

    // ç”¨TextDecoderè§£æï¼Œä¿è¯UTF-8å…¼å®¹
    const decrypted = new TextDecoder("utf-8").decode(byteArray);

    // å°†è§£å¯†å†…å®¹æ’å…¥å®¹å™¨
    const decryptedContent = container.querySelector('.decrypted-content');
    decryptedContent.innerHTML = decrypted;

    // éšè—åŠ å¯†æç¤º
    container.querySelector('.locked-state').hidden = true;
    decryptedContent.hidden = false;
    container.classList.add('unlocked');

    // è°ƒç”¨å¯èƒ½çš„Markdownæ¸²æŸ“æ–¹æ³•
    if (typeof simpleMarkdown === 'function') {
        decryptedContent.innerHTML = simpleMarkdown(decrypted);
    }

} catch (e) {
    console.error('Decryption failed:', e);
    statusEl.textContent = `è§£ç å¤±è´¥: ${e.message}`;
    statusEl.classList.add('error');
}
}

function simpleMarkdown(str) {
  return str
    // å¤„ç†æ ‡é¢˜
    .replace(/^####\s+(.+)$/gm, '<h4>$1</h4>')
    .replace(/^###\s+(.+)$/gm, '<h3>$1</h3>')
    .replace(/^##\s+(.+)$/gm, '<h2>$1</h2>')
    .replace(/^#\s+(.+)$/gm, '<h1>$1</h1>')
    
    // å¤„ç†ç²—ä½“
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    
    // å¤„ç†æ–œä½“
    .replace(/\*(.+?)\*/g, '<em>$1</em>')
    
    // å¤„ç†åˆ é™¤çº¿
    .replace(/~~(.+?)~~/g, '<del>$1</del>')
    
    // å¤„ç†å†…è”ä»£ç 
    .replace(/`(.+?)`/g, '<code>$1</code>')
    
    // å¤„ç†ä»£ç å—
    // .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
    
    // å¤„ç†æ— åºåˆ—è¡¨
    .replace(/^\s*\*\s+(.+)$/gm, '<ul><li>$1</li></ul>')
    .replace(/<\/ul>\n<ul>/g, '') // åˆå¹¶ç›¸é‚»çš„ ul æ ‡ç­¾
    
    // å¤„ç†æœ‰åºåˆ—è¡¨
    .replace(/^\s*\d+\.\s+(.+)$/gm, '<ol><li>$1</li></ol>')
    .replace(/<\/ol>\n<ol>/g, '') // åˆå¹¶ç›¸é‚»çš„ ol æ ‡ç­¾
    
    // å¤„ç†é“¾æ¥
    .replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2">$1</a>')
    
    // å¤„ç†å›¾ç‰‡
    .replace(/!\[(.+?)\]\((.+?)\)/g, '<img src="$2" alt="$1">')
    
    // å¤„ç†å¼•ç”¨
    .replace(/^>\s+(.+)$/gm, '<blockquote>$1</blockquote>')
    
    // å¤„ç†æ°´å¹³åˆ†å‰²çº¿
    .replace(/^\s*---\s*$/gm, '<hr>')
    
    // ç§»é™¤å¤šä¸ªç©ºè¡Œï¼Œåªä¿ç•™ä¸€ä¸ª
    .replace(/\n{2,}/g, '\n\n')
    
    // å°†åŒæ¢è¡Œç¬¦è½¬æ¢ä¸º <br> æ ‡ç­¾
    .replace(/\n\n/g, '<br>');
}

// æ·»åŠ é”®ç›˜å›è½¦æ”¯æŒ
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.password-input').forEach(input => {
    input.addEventListener('keypress', e => {
      if (e.key === 'Enter') {
        decryptContent(e, e.target.id);
      }
    });
  });
});
</script>
